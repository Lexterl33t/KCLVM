use std::{collections::HashMap, path::Path, sync::Arc, time::SystemTime};

use anyhow::Result;
use assembler::KclvmLibAssembler;
use kclvm_ast::{
    ast::{Module, Program},
    MAIN_PKG,
};
use kclvm_driver::canonicalize_input_files;
use kclvm_error::{Diagnostic, Handler};
use kclvm_parser::{load_program, ParseSession};
use kclvm_query::apply_overrides;
use kclvm_runtime::{PanicInfo, ValueRef};
use kclvm_sema::resolver::resolve_program;
use linker::Command;
pub use runner::ExecProgramArgs;
use runner::{ExecProgramResult, KclvmRunner, KclvmRunnerOptions};
use tempfile::tempdir;

pub mod assembler;
pub mod linker;
pub mod runner;

#[cfg(test)]
pub mod tests;

/// After the kcl program passed through kclvm-parser in the compiler frontend,
/// KCLVM needs to resolve ast, generate corresponding LLVM IR, dynamic link library or
/// executable file for kcl program in the compiler backend.
///
/// Method “execute” is the entry point for the compiler backend.
///
/// It returns the KCL program executing result as Result<a_json_string, an_err_string>,
/// and mainly takes "program" (ast.Program returned by kclvm-parser) as input.
///
/// "args" is the items selected by the user in the KCLVM CLI.
///
/// This method will first resolve “program” (ast.Program) and save the result to the "scope" (ProgramScope).
///
/// Then, dynamic link libraries is generated by KclvmAssembler, and method "KclvmAssembler::gen_libs"
/// will return dynamic link library paths in a "Vec<String>";
///
/// KclvmAssembler is mainly responsible for concurrent compilation of multiple files.
/// Single-file compilation in each thread in concurrent compilation is the responsibility of KclvmLibAssembler.
/// In the future, it may support the dynamic link library generation of multiple intermediate language.
/// KclvmLibAssembler currently only supports LLVM IR.
///
/// After linking all dynamic link libraries by KclvmLinker, method "KclvmLinker::link_all_libs" will return a path
/// for dynamic link library after linking.
///
/// At last, KclvmRunner will be constructed and call method "run" to execute the kcl program.
///
/// **Note that it is not thread safe.**
///
/// # Examples
///
/// ```
/// use kclvm_runner::{exec_program, ExecProgramArgs};
/// use kclvm_parser::ParseSession;
/// use std::sync::Arc;
///
/// // Create sessions
/// let sess = Arc::new(ParseSession::default());
/// // Get default args
/// let mut args = ExecProgramArgs::default();
/// args.k_filename_list = vec!["./src/test_datas/init_check_order_0/main.k".to_string()];
///
/// // Resolve ast, generate libs, link libs and execute.
/// // Result is the kcl in json format.
/// let result = exec_program(sess, &args).unwrap();
/// ```
pub fn exec_program(
    sess: Arc<ParseSession>,
    args: &ExecProgramArgs,
) -> Result<ExecProgramResult, String> {
    // parse args from json string
    let opts = args.get_load_program_options();
    let k_files = &args.k_filename_list;
    let work_dir = args.work_dir.clone().unwrap_or_default();
    let kcl_paths = canonicalize_input_files(k_files, work_dir, false)?;

    let kcl_paths_str = kcl_paths.iter().map(|s| s.as_str()).collect::<Vec<&str>>();

    let mut program = load_program(sess.clone(), kcl_paths_str.as_slice(), Some(opts))?;

    if let Err(err) = apply_overrides(
        &mut program,
        &args.overrides,
        &[],
        args.print_override_ast || args.debug > 0,
    ) {
        return Err(err.to_string());
    }

    let start_time = SystemTime::now();
    let exec_result = execute(sess, program, args);
    let escape_time = match SystemTime::now().duration_since(start_time) {
        Ok(dur) => dur.as_secs_f32(),
        Err(err) => return Err(err.to_string()),
    };
    let mut result = ExecProgramResult {
        escaped_time: escape_time.to_string(),
        ..Default::default()
    };
    // Exec result is a JSON or YAML string.
    let exec_result = match exec_result {
        Ok(res) => {
            if res.is_empty() {
                return Ok(result);
            } else {
                res
            }
        }
        Err(res) => {
            if res.is_empty() {
                return Ok(result);
            } else {
                return Err(res);
            }
        }
    };
    let kcl_val = match ValueRef::from_yaml_stream(&exec_result) {
        Ok(v) => v,
        Err(err) => return Err(err.to_string()),
    };
    // Filter values with the path selector.
    let kcl_val = kcl_val.filter_by_path(&args.path_selector)?;
    // Plan values.
    let (json_result, yaml_result) = kcl_val.plan(args.sort_keys);
    result.json_result = json_result;
    if !args.disable_yaml_result {
        result.yaml_result = yaml_result;
    }
    Ok(result)
}

/// After the kcl program passed through kclvm-parser in the compiler frontend,
/// KCLVM needs to resolve ast, generate corresponding LLVM IR, dynamic link library or
/// executable file for kcl program in the compiler backend.
///
/// Method “execute” is the entry point for the compiler backend.
///
/// It returns the KCL program executing result as Result<a_json_string, an_err_string>,
/// and mainly takes "program" (ast.Program returned by kclvm-parser) as input.
///
/// "args" is the items selected by the user in the KCLVM CLI.
///
/// This method will first resolve “program” (ast.Program) and save the result to the "scope" (ProgramScope).
///
/// Then, dynamic link libraries is generated by KclvmAssembler, and method "KclvmAssembler::gen_libs"
/// will return dynamic link library paths in a "Vec<String>";
///
/// KclvmAssembler is mainly responsible for concurrent compilation of multiple files.
/// Single-file compilation in each thread in concurrent compilation is the responsibility of KclvmLibAssembler.
/// In the future, it may support the dynamic link library generation of multiple intermediate language.
/// KclvmLibAssembler currently only supports LLVM IR.
///
/// After linking all dynamic link libraries by KclvmLinker, method "KclvmLinker::link_all_libs" will return a path
/// for dynamic link library after linking.
///
/// At last, KclvmRunner will be constructed and call method "run" to execute the kcl program.
///
/// **Note that it is not thread safe.**
///
/// # Examples
///
/// ```
/// use kclvm_runner::{execute, runner::ExecProgramArgs};
/// use kclvm_parser::{load_program, ParseSession};
/// use kclvm_ast::ast::Program;
/// use std::sync::Arc;
///
/// // Create sessions
/// let sess = Arc::new(ParseSession::default());
/// // Get default args
/// let args = ExecProgramArgs::default();
/// let opts = args.get_load_program_options();
///
/// // Parse kcl file
/// let kcl_path = "./src/test_datas/init_check_order_0/main.k";
/// let prog = load_program(sess.clone(), &[kcl_path], Some(opts)).unwrap();
///     
/// // Resolve ast, generate libs, link libs and execute.
/// // Result is the kcl in json format.
/// let result = execute(sess, prog, &args).unwrap();
/// ```
pub fn execute(
    sess: Arc<ParseSession>,
    mut program: Program,
    args: &ExecProgramArgs,
) -> Result<String, String> {
    // Resolve ast
    let scope = resolve_program(&mut program);
    scope.emit_diagnostics_to_string(sess.0.clone())?;

    // Create a temp entry file and the temp dir will be delete automatically
    let temp_dir = tempdir().map_err(|e| e.to_string())?;
    let temp_dir_path = temp_dir.path().to_str().ok_or(format!(
        "Internal error: {}: No such file or directory",
        temp_dir.path().display()
    ))?;
    let temp_entry_file = temp_file(temp_dir_path).map_err(|e| e.to_string())?;

    // Generate libs
    let lib_paths = assembler::KclvmAssembler::new(
        program,
        scope,
        temp_entry_file.clone(),
        KclvmLibAssembler::LLVM,
        args.get_package_maps_from_external_pkg(),
    )
    .gen_libs()
    .map_err(|e| e.to_string())?;

    // Link libs
    let lib_suffix = Command::get_lib_suffix();
    let temp_out_lib_file = format!("{}{}", temp_entry_file, lib_suffix);
    let lib_path = linker::KclvmLinker::link_all_libs(lib_paths, temp_out_lib_file)
        .map_err(|e| e.to_string())?;

    // Run
    let runner = KclvmRunner::new(Some(KclvmRunnerOptions {
        plugin_agent_ptr: args.plugin_agent,
    }));
    let result = runner.run(&lib_path, args);

    // Clean temp files.
    // FIXME(issue #346): On windows, sometimes there will be an error that the file cannot be accessed.
    // Therefore, the function of automatically deleting dll files on windows is temporarily turned off.
    #[cfg(not(target_os = "windows"))]
    remove_file(&lib_path).map_err(|e| e.to_string())?;
    #[cfg(not(target_os = "windows"))]
    clean_tmp_files(&temp_entry_file, &lib_suffix).map_err(|e| e.to_string())?;
    // Wrap runtime error into diagnostic style string.
    result.map_err(|err| {
        match Handler::default()
            .add_diagnostic(<PanicInfo as Into<Diagnostic>>::into(PanicInfo::from(err)))
            .emit_to_string()
        {
            Ok(msg) => msg,
            Err(err) => err.to_string(),
        }
    })
}

/// `execute_module` can directly execute the ast `Module`.
/// `execute_module` constructs `Program` with default pkg name `MAIN_PKG`,
/// and calls method `execute` with default `plugin_agent` and `ExecProgramArgs`.
/// For more information, see doc above method `execute`.
///
/// **Note that it is not thread safe.**
pub fn execute_module(mut m: Module) -> Result<String, String> {
    m.pkg = MAIN_PKG.to_string();

    let mut pkgs = HashMap::new();
    pkgs.insert(MAIN_PKG.to_string(), vec![m]);

    let prog = Program {
        root: MAIN_PKG.to_string(),
        main: MAIN_PKG.to_string(),
        pkgs,
    };

    execute(
        Arc::new(ParseSession::default()),
        prog,
        &ExecProgramArgs::default(),
    )
}

/// Clean all the tmp files generated during lib generating and linking.
#[inline]
fn clean_tmp_files(temp_entry_file: &String, lib_suffix: &String) -> Result<()> {
    let temp_entry_lib_file = format!("{}{}", temp_entry_file, lib_suffix);
    remove_file(&temp_entry_lib_file)
}

#[inline]
fn remove_file(file: &str) -> Result<()> {
    if Path::new(&file).exists() {
        std::fs::remove_file(file)?;
    }
    Ok(())
}

/// Returns a temporary file name consisting of timestamp and process id.
fn temp_file(dir: &str) -> Result<String> {
    let timestamp = chrono::Local::now().timestamp_nanos();
    let id = std::process::id();
    let file = format!("{}_{}", id, timestamp);
    std::fs::create_dir_all(dir)?;
    Ok(Path::new(dir)
        .join(file)
        .to_str()
        .ok_or(anyhow::anyhow!("{dir} not found"))?
        .to_string())
}
